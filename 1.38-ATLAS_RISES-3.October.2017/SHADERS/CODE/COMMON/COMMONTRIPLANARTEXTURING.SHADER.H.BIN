////////////////////////////////////////////////////////////////////////////////
///
///     @file       CommonTriplanarTexturing.h
///     @author     User
///     @date       
///
///     @brief      CommonTriplanarTexturing
///
///     Copyright (c) 2008 Hello Games Ltd. All Rights Reserved.
///
////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//      Compilation defines 


//-----------------------------------------------------------------------------
//      Include files
#ifndef D_COMMONTRIPLANARTEXTURING
#define D_COMMONTRIPLANARTEXTURING

#include "Common/CommonFragment.shader.h"


//-----------------------------------------------------------------------------
//      Global Data


#if defined(D_PLATFORM_PC)
uniform vec4 gaAverageColoursVec4[ D_TERRAINCOLOURARRAY_SIZE ];
uniform vec4 gaTerrainColoursVec4[ D_TERRAINCOLOURARRAY_SIZE ];
#endif


//-----------------------------------------------------------------------------
//      Functions


vec3
GetTriPlanarColour(
    vec3  lNormalVec3,
    vec3  lWorldPositionVec3,
    vec2  lAnimationOffsetVec2,
    float lfScale,
    SAMPLER2DARG( lTexture ) )
{
    #if defined( D_TERRAIN_X_FACING )
    vec3    m = vec3( 1.0, 0.0, 0.0 );
    #elif defined( D_TERRAIN_Y_FACING )
    vec3    m = vec3( 0.0, 1.0, 0.0 );
    #elif defined( D_TERRAIN_Z_FACING )
    vec3    m = vec3( 0.0, 0.0, 1.0 );
    #else
    vec3    m = pow( abs( lNormalVec3 ), vec3( 32.0,32.0,32.0 ) );
    #endif

    vec2  lCoord1Vec2 = lWorldPositionVec3.yz * lfScale + lAnimationOffsetVec2;
    vec2  lCoord2Vec2 = lWorldPositionVec3.zx * lfScale + lAnimationOffsetVec2;
    vec2  lCoord3Vec2 = lWorldPositionVec3.xy * lfScale + lAnimationOffsetVec2;

    vec3 lColour1Vec3 = texture2DLod( lTexture, lCoord1Vec2, 0.0 ).rgb;
    vec3 lColour2Vec3 = texture2DLod( lTexture, lCoord2Vec2, 0.0 ).rgb;
    vec3 lColour3Vec3 = texture2DLod( lTexture, lCoord3Vec2, 0.0 ).rgb;

    return ( lColour1Vec3 * m.x + lColour2Vec3 * m.y + lColour3Vec3 * m.z ) / (m.x + m.y + m.z);
}

// mip-mapped variant of the above

vec3
GetTriPlanarColourMM(
    vec3  lNormalVec3,
    vec3  lWorldPositionVec3,
    vec2  lAnimationOffsetVec2,
    float lfScale,
    SAMPLER2DARG( lTexture ) )
{
    #if defined( D_TERRAIN_X_FACING )
    vec3    m = vec3( 1.0, 0.0, 0.0 );
    #elif defined( D_TERRAIN_Y_FACING )
    vec3    m = vec3( 0.0, 1.0, 0.0 );
    #elif defined( D_TERRAIN_Z_FACING )
    vec3    m = vec3( 0.0, 0.0, 1.0 );
    #else
    vec3    m = pow( abs( lNormalVec3 ), vec3( 32.0,32.0,32.0 ) );
    #endif

    vec2  lCoord1Vec2 = lWorldPositionVec3.yz * lfScale + lAnimationOffsetVec2;
    vec2  lCoord2Vec2 = lWorldPositionVec3.zx * lfScale + lAnimationOffsetVec2;
    vec2  lCoord3Vec2 = lWorldPositionVec3.xy * lfScale + lAnimationOffsetVec2;

    vec3 lColour1Vec3 = texture2DComputeGrad( lTexture, lCoord1Vec2 ).rgb;
    vec3 lColour2Vec3 = texture2DComputeGrad( lTexture, lCoord2Vec2 ).rgb;
    vec3 lColour3Vec3 = texture2DComputeGrad( lTexture, lCoord3Vec2 ).rgb;

    return ( lColour1Vec3 * m.x + lColour2Vec3 * m.y + lColour3Vec3 * m.z ) / (m.x + m.y + m.z);
}


vec3
GetTriPlanarNormal(
    vec3  lNormalVec3,
    vec3  lWorldPositionVec3,
    vec2  lAnimationOffsetVec2,
    float lfScale,
    SAMPLER2DARG( lTexture ) )
{
    #if defined( D_TERRAIN_X_FACING )
    vec3    m = vec3( 1.0, 0.0, 0.0 );
    #elif defined( D_TERRAIN_Y_FACING )
    vec3    m = vec3( 0.0, 1.0, 0.0 );
    #elif defined( D_TERRAIN_Z_FACING )
    vec3    m = vec3( 0.0, 0.0, 1.0 );
    #else
    vec3    m = pow( abs( lNormalVec3 ), vec3( 32.0,32.0,32.0 ) );
    #endif

    vec2  lCoord1Vec2 = vec2( lWorldPositionVec3.z, -lWorldPositionVec3.y ) * lfScale + lAnimationOffsetVec2;
    vec2  lCoord2Vec2 = vec2( lWorldPositionVec3.z, lWorldPositionVec3.x ) * lfScale + lAnimationOffsetVec2;
    vec2  lCoord3Vec2 = vec2( lWorldPositionVec3.x, -lWorldPositionVec3.y ) * lfScale + lAnimationOffsetVec2;

    vec3 lNormal1Vec3 = DecodeNormalMap( texture2D( lTexture, lCoord1Vec2 ) );
    vec3 lNormal2Vec3 = DecodeNormalMap( texture2D( lTexture, lCoord2Vec2 ) );
    vec3 lNormal3Vec3 = DecodeNormalMap( texture2D( lTexture, lCoord3Vec2 ) );

    lNormal1Vec3 = vec3( 0.0, lNormal1Vec3.x, lNormal1Vec3.y );  // YZ 
    lNormal2Vec3 = vec3( -lNormal2Vec3.x, 0.0, lNormal2Vec3.y );  // ZX
    lNormal3Vec3 = vec3( lNormal3Vec3.y, lNormal3Vec3.x, 0.0 );  // XY

    return (lNormal1Vec3 * m.x + lNormal2Vec3 * m.y + lNormal3Vec3 * m.z) / (m.x + m.y + m.z);
}


#ifdef D_TEXTURE_ARRAYS
//-----------------------------------------------------------------------------
///
///     GetTriPlanarNormal
///
///     @brief      GetTriPlanarNormal
///
///     @param      void
///     @return     Nothing.
///
//-----------------------------------------------------------------------------
vec3
GetTriPlanarNormalArray(
    in  vec2           lCoordVec2,
    SAMPLER2DARRAYARG( lNormalMap ),
    SAMPLER2DARRAYARG( lSubstanceNormalMap ),
    in  int            liIndex,
    out float          lfHeight,
    out float          lfSpecular )
{
    vec4 lTexValueVec4;

    if( liIndex < 16 )
    {
        lTexValueVec4 = texture2DArray( lNormalMap, vec3( lCoordVec2, float( liIndex ) ) );
    }
    else
    {
        lTexValueVec4 = texture2DArray( lSubstanceNormalMap, vec3( lCoordVec2, float( liIndex & 15 ) ) );
    }
    //vec3 lLocalNormalAVec3 = DecodeNormalMap( lTexValueVec4 );
    vec3 lLocalNormalAVec3 = vec3( lTexValueVec4.a * 2.0 - 1.0, lTexValueVec4.g * 2.0 - 1.0, 0.0 );
    lfHeight   = lTexValueVec4.r;
    lfSpecular = lTexValueVec4.b;
    return lLocalNormalAVec3;

}
//-----------------------------------------------------------------------------
///
///     GetTriPlanarColour
///
///     @brief      GetTriPlanarColour
///
///     @param      void
///     @return     Nothing.
///
//-----------------------------------------------------------------------------
vec3
GetTriPlanarColourArray(
    in vec2            lCoordVec2,
    SAMPLER2DARRAYARG( lDiffuseMap ),
    SAMPLER2DARRAYARG( lSubstanceDiffuseMap ),
    in int             liIndex,
    in vec3            lAverageHSVVec3,
    in vec3            lRecolourVec3 )
{
    vec3 lColourVec3;
    if( liIndex < 16 )
    {
        lColourVec3 = texture2DArray( lDiffuseMap, vec3( lCoordVec2, float( liIndex ) ) ).rgb;
    }
    else
    {
        lColourVec3 = texture2DArray( lSubstanceDiffuseMap, vec3( lCoordVec2, float( liIndex & 15 ) ) ).rgb;
    }
    lColourVec3.r = fract( ( lColourVec3.r - lAverageHSVVec3.r ) + lRecolourVec3.r );
    lColourVec3.g = saturate( min( lRecolourVec3.g, lColourVec3.g ) );
    lColourVec3.b = saturate( ( lColourVec3.b - lAverageHSVVec3.b ) + lRecolourVec3.b );
    lColourVec3   = saturate( HSVToRGB( lColourVec3 ) );

    return lColourVec3;
}


//-----------------------------------------------------------------------------
///
///     GetBlendedNormal
///
///     @brief      GetBlendedNormal
///
///     @param      void
///     @return     Nothing.
///
//-----------------------------------------------------------------------------
vec3
GetBlendedNormal(
    in    vec2         lTileCoordsVec2,
    SAMPLER2DARRAYARG( lNormalMap ),
    SAMPLER2DARRAYARG( lSubstanceNormalMap ),
    in    uvec4        lTile1Vec4,
    in    uvec4        lTile2Vec4,
    in    float        lfTileType,
    in    float        lfSlope,
    in    float        lfPatch,
    out   float        lfSpecular,
    out   float        lfHeight1,
    out   float        lfHeight2,
    out   float        lfHeight3,
    out   float        lfHeight4,
    out   float        lfHeight5,
    out   float        lfHeight6,
    out   float        lfHeight7 )
{
#ifndef D_LOW_QUALITY

    const float lfThreshold     = 1.0 / 100.0;
    const float lfOffset        = 0.12;
    const float lfDefaultHeight = 0.5;

    vec3  lNormal5    = vec3( 0.0, 0.0, 0.0 );
    vec3  lNormal6    = vec3( 0.0, 0.0, 0.0 );
    float lfSpecular1 = 0.0;
    float lfSpecular2 = 0.0;
    float lfSpecular3 = 0.0;
    float lfSpecular4 = 0.0;
    float lfSpecular5 = 0.0;
    float lfSpecular6 = 0.0;
    lfHeight1         = 0.0;
    lfHeight2         = 0.0;
    lfHeight3         = 0.0;
    lfHeight4         = 0.0;
    lfHeight5         = 0.0;
    lfHeight6         = 0.0;
    lfHeight7         = 0.0;

    float lfHeightE = lfDefaultHeight;
    float lfHeightF = lfDefaultHeight;

    if( lfPatch < 1.0 - lfThreshold )
    {
        float lfHeightC = lfDefaultHeight;
        float lfHeightD = lfDefaultHeight;

        vec3  lNormal1 = vec3(0.0, 0.0, 0.0);
        vec3  lNormal2 = vec3(0.0, 0.0, 0.0);
        vec3  lNormal3 = vec3(0.0, 0.0, 0.0);
        vec3  lNormal4 = vec3(0.0, 0.0, 0.0);

        if( lfSlope < 1.0 - lfThreshold )
        {

            float lfHeightA = lfDefaultHeight;
            float lfHeightB = lfDefaultHeight;

            if( lfTileType < 1.0 - lfThreshold )
            {
                lNormal1 = GetTriPlanarNormalArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), int( lTile1Vec4[ 0 ] ), lfHeightA, lfSpecular1 );
            }

            if( lfTileType > lfThreshold )
            {
                lNormal2 = GetTriPlanarNormalArray( lTileCoordsVec2,SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ),  int( lTile1Vec4[ 1 ] ), lfHeightB, lfSpecular2 );
            }

             // blend between height textures
            lfHeight1      = mix( lfHeightA, 1.0 - lfHeightB, lfTileType );

            // use height as a cutoff for smoothstep to get sharp transition between height maps
            float lfHeight = smoothstep( lfHeight1 - lfOffset, lfHeight1 + lfOffset, lfTileType );

            lfSpecular3    = mix( lfSpecular1, lfSpecular2, lfHeight );
            lNormal3       = mix( lNormal1,    lNormal2,    lfHeight );

            // blend between height maps again to get map which can be combined with other height maps
            lfHeightC      = mix( lfHeightA,   lfHeightB,   lfHeight );
        }

        if( lfSlope > lfThreshold )
        {
            float lfHeightA = lfDefaultHeight;
            float lfHeightB = lfDefaultHeight;

            if( lfTileType < 1.0 - lfThreshold )
            {
                lNormal1 = GetTriPlanarNormalArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), int( lTile1Vec4[ 2 ] ), lfHeightA, lfSpecular1 );
            }

            if( lfTileType > lfThreshold )
            {
                lNormal2 = GetTriPlanarNormalArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), int( lTile1Vec4[ 3 ] ), lfHeightB, lfSpecular2 );
            }

            lfHeight2      = mix( lfHeightA, 1.0 - lfHeightB, lfTileType );
            float lfHeight = smoothstep( lfHeight2 - lfOffset, lfHeight2 + lfOffset, lfTileType );

            lfSpecular4    = mix( lfSpecular1, lfSpecular2, lfHeight );
            lNormal4       = mix( lNormal1,    lNormal2,    lfHeight );
            lfHeightD      = mix( lfHeightA,   lfHeightB,   lfHeight );

        }

        lfHeight5      = mix( lfHeightC, 1.0 - lfHeightD, lfSlope );
        float lfHeight = smoothstep( lfHeight5 - lfOffset, lfHeight5 + lfOffset, lfSlope );

        lfSpecular5    = mix( lfSpecular3, lfSpecular4, lfHeight );
        lNormal5       = mix( lNormal3,    lNormal4,    lfHeight );
        lfHeightE      = mix( lfHeightC,   lfHeightD,   lfHeight );
    }

    if( lfPatch > lfThreshold )
    {
        vec3  lNormal1 = vec3(0.0, 0.0, 0.0);
        vec3  lNormal2 = vec3(0.0, 0.0, 0.0);
        vec3  lNormal3 = vec3(0.0, 0.0, 0.0);
        vec3  lNormal4 = vec3(0.0, 0.0, 0.0);

        float lfHeightC = lfDefaultHeight;
        float lfHeightD = lfDefaultHeight;

        if( lfSlope < 1.0 - lfThreshold )
        {
            float lfHeightA = lfDefaultHeight;
            float lfHeightB = lfDefaultHeight;

            if( lfTileType < 1.0 - lfThreshold )
            {
                lNormal1 = GetTriPlanarNormalArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), int( lTile2Vec4[ 0 ] ), lfHeightA, lfSpecular1 );
            }

            if( lfTileType > lfThreshold )
            {
                lNormal2 = GetTriPlanarNormalArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), int( lTile2Vec4[ 1 ] ), lfHeightB, lfSpecular2 );
            }

            lfHeight3      = mix( lfHeightA, 1.0 - lfHeightB, lfTileType );
            float lfHeight = smoothstep( lfHeight3 - lfOffset, lfHeight3 + lfOffset, lfTileType );

            lfSpecular3  = mix( lfSpecular1, lfSpecular2,     lfHeight );
            lNormal3     = mix( lNormal1,    lNormal2,        lfHeight );
            lfHeightC    = mix( lfHeightA,   1.0 - lfHeightB, lfHeight );

        }

        if( lfSlope > lfThreshold )
        {
            float lfHeightA = lfDefaultHeight;
            float lfHeightB = lfDefaultHeight;

            if( lfTileType < 1.0 - lfThreshold )
            {
                lNormal1 = GetTriPlanarNormalArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), int( lTile2Vec4[ 2 ] ), lfHeightA, lfSpecular1 );
            }

            if( lfTileType > lfThreshold )
            {
                lNormal2 = GetTriPlanarNormalArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), int( lTile2Vec4[ 3 ] ), lfHeightB, lfSpecular2 );
            }

            lfHeight4      = mix( lfHeightA, 1.0 - lfHeightB, lfTileType );
            float lfHeight = smoothstep( lfHeight4 - lfOffset, lfHeight4 + lfOffset, lfTileType );

            lfSpecular4    = mix( lfSpecular1, lfSpecular2, lfHeight );
            lNormal4       = mix( lNormal1,    lNormal2,    lfHeight );
            lfHeightD      = mix( lfHeightA,   lfHeightB,   lfHeight );
        }

        lfHeight6      = mix( lfHeightC, 1.0 - lfHeightD, lfSlope );
        float lfHeight = smoothstep( lfHeight6 - lfOffset, lfHeight6 + lfOffset, lfSlope );

        lfSpecular6    = mix( lfSpecular3, lfSpecular4, lfHeight );
        lNormal6       = mix( lNormal3,    lNormal4,    lfHeight );
        lfHeightF      = mix( lfHeightC,   lfHeightD,   lfHeight );
    }

    lfHeight7      = mix( lfHeightE, 1.0 - lfHeightF, lfPatch );
    float lfHeight = smoothstep( lfHeight7 - lfOffset, lfHeight7 + lfOffset, lfPatch );

    lfSpecular     = mix( lfSpecular5, lfSpecular6, lfHeight );
    return mix( lNormal5, lNormal6, lfHeight );

#else

    vec3 lNormal = GetTriPlanarNormalArray(
        lTileCoordsVec2,
        SAMPLER2DARRAYPARAM( lNormalMap ),
        SAMPLER2DARRAYPARAM( lSubstanceNormalMap ),
        int( lTile1Vec4[ 0 ] ),
        lfHeight1,
        lfSpecular );

    lfHeight2 = lfHeight1;
    lfHeight3 = lfHeight1;
    lfHeight4 = lfHeight1;
    lfHeight5 = lfHeight1;
    lfHeight6 = lfHeight1;
    lfHeight7 = lfHeight1;

    return lNormal;

#endif
}


vec3
GetBlendedColour(
    in  CustomPerMaterialUniforms lCustomUniforms,
    in    vec2         lTileCoordsVec2,
    SAMPLER2DARRAYARG( lDiffuseMap ),
    SAMPLER2DARRAYARG( lSubstanceDiffuseMap ),
    in    vec4         lTile1Vec4,
    in    vec4         lTile2Vec4,
    in    float        lfHeight1,
    in    float        lfHeight2,
    in    float        lfHeight3,
    in    float        lfHeight4,
    in    float        lfHeight5,
    in    float        lfHeight6,
    in    float        lfHeight7,
    out   float        lfMetallic )
{
    lfMetallic = 0.0;
#ifndef D_LOW_QUALITY
    const float lfThreshold = 1.0 / 100.0;
    vec3  lColour5    = vec3( 0.0, 0.0, 0.0 );
    vec3  lColour6    = vec3( 0.0, 0.0, 0.0 );
    float lfMetallic5 = 0.0;
    float lfMetallic6 = 0.0;

    if( lfHeight7 < 1.0 - lfThreshold )
    {
#ifdef D_PLATFORM_PC
        if( lfHeight5 < 1.0 - lfThreshold )
#endif
        {
            if( ( 1.0 - lfHeight1 ) * ( 1.0 - lfHeight5 ) > lfThreshold )
            {
                int liIndex = int( floor( lTile1Vec4.x ) );
                vec3 lOriginalColourVec3 = ARRAY_LOOKUP_FS( lCustomUniforms, gaAverageColoursVec4, liIndex ).rgb;
                vec3 lRecolourVec3       = ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).rgb;
                lfMetallic5             += ( 1.0 - lfHeight1 ) * ( 1.0 - lfHeight5 ) *  ( 1.0 - ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).a );
                lColour5                += ( 1.0 - lfHeight1 ) * ( 1.0 - lfHeight5 ) * GetTriPlanarColourArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), liIndex, lOriginalColourVec3, lRecolourVec3 ).xyz;
            
            }
            if( lfHeight1 * ( 1.0 - lfHeight5 ) > lfThreshold )
            {
                int liIndex = int( floor( lTile1Vec4.y ) );
                vec3 lOriginalColourVec3 = ARRAY_LOOKUP_FS( lCustomUniforms, gaAverageColoursVec4, liIndex ).rgb;
                vec3 lRecolourVec3       = ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).rgb;
                lfMetallic5             += lfHeight1 * ( 1.0 - lfHeight5 ) * ( 1.0 - ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).a );
                lColour5                += lfHeight1 * ( 1.0 - lfHeight5 ) * GetTriPlanarColourArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), liIndex, lOriginalColourVec3, lRecolourVec3 ).xyz;
            }
        }
#ifdef D_PLATFORM_PC
        if( lfHeight5 > lfThreshold )
#endif
        {
            if( ( 1.0 - lfHeight2 ) * lfHeight5 > lfThreshold )
            {
                int liIndex = int( floor( lTile1Vec4.z ) );
                vec3 lOriginalColourVec3 = ARRAY_LOOKUP_FS( lCustomUniforms, gaAverageColoursVec4, liIndex ).rgb;
                vec3 lRecolourVec3       = ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).rgb;
                lfMetallic5             += ( 1.0 - lfHeight2 ) * lfHeight5 *  ( 1.0 - ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).a );
                lColour5                += ( 1.0 - lfHeight2 ) * lfHeight5 * GetTriPlanarColourArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), liIndex, lOriginalColourVec3, lRecolourVec3 ).xyz;
            }
            if( lfHeight2 * lfHeight5 > lfThreshold )
            {
                int liIndex = int( floor( lTile1Vec4.w ) );
                vec3 lOriginalColourVec3 = ARRAY_LOOKUP_FS( lCustomUniforms, gaAverageColoursVec4, liIndex ).rgb;
                vec3 lRecolourVec3       = ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).rgb;
                lfMetallic5             += lfHeight2 * lfHeight5 * ( 1.0 - ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).a );
                lColour5                += lfHeight2 * lfHeight5 * GetTriPlanarColourArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), liIndex, lOriginalColourVec3, lRecolourVec3 ).xyz;
            }
        }
    }

    if( lfHeight7 > lfThreshold )
    {
#ifdef D_PLATFORM_PC
         if( lfHeight6 < 1.0 - lfThreshold )
#endif
        {
            if( ( 1.0 - lfHeight3 ) * ( 1.0 - lfHeight6 ) > lfThreshold )
            {
                int liIndex = int( floor( lTile2Vec4.x ) );
                vec3 lOriginalColourVec3 = ARRAY_LOOKUP_FS( lCustomUniforms, gaAverageColoursVec4, liIndex ).rgb;
                vec3 lRecolourVec3       = ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).rgb;
                lfMetallic6             += ( 1.0 - lfHeight3 ) * ( 1.0 - lfHeight6 ) * ( 1.0 - ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).a );
                lColour6                += ( 1.0 - lfHeight3 ) * ( 1.0 - lfHeight6 ) * GetTriPlanarColourArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), liIndex, lOriginalColourVec3, lRecolourVec3 ).xyz;
            }
            if( lfHeight3 * ( 1.0 - lfHeight6 ) > lfThreshold )
            {
                int liIndex = int( floor( lTile2Vec4.y ) );
                vec3 lOriginalColourVec3 = ARRAY_LOOKUP_FS( lCustomUniforms, gaAverageColoursVec4, liIndex ).rgb;
                vec3 lRecolourVec3       = ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).rgb;
                lfMetallic6             += lfHeight3 * ( 1.0 - lfHeight6 ) * ( 1.0 - ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).a );
                lColour6                += lfHeight3 * ( 1.0 - lfHeight6 ) * GetTriPlanarColourArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), liIndex, lOriginalColourVec3, lRecolourVec3 ).xyz;
            }
        }
#ifdef D_PLATFORM_PC
        if( lfHeight6 > lfThreshold )
#endif
        {
            if( ( 1.0 - lfHeight4 ) * lfHeight6 > lfThreshold )
            {
                int liIndex = int( floor( lTile2Vec4.z ) );
                vec3 lOriginalColourVec3 = ARRAY_LOOKUP_FS( lCustomUniforms, gaAverageColoursVec4, liIndex ).rgb;
                vec3 lRecolourVec3       = ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).rgb;
                lfMetallic6             += ( 1.0 - lfHeight4 ) * lfHeight6 * ( 1.0 - ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).a );
                lColour6                += ( 1.0 - lfHeight4 ) * lfHeight6 * GetTriPlanarColourArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), liIndex, lOriginalColourVec3, lRecolourVec3 ).xyz;
            }
#ifdef D_DEFER
            if( lfHeight4 * lfHeight6 > lfThreshold )
            {
                int liIndex = int( floor( lTile2Vec4.w ) );
                vec3 lOriginalColourVec3 = ARRAY_LOOKUP_FS( lCustomUniforms, gaAverageColoursVec4, liIndex ).rgb;
                vec3 lRecolourVec3       = ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).rgb;
                lfMetallic6             += lfHeight4 * lfHeight6 * ( 1.0 - ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).a );
                lColour6                += lfHeight4 * lfHeight6 * GetTriPlanarColourArray( lTileCoordsVec2, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), liIndex, lOriginalColourVec3, lRecolourVec3 ).xyz;
            }
#endif
        }
    }

    lfMetallic = mix( lfMetallic5, lfMetallic6, lfHeight7 );
    return       mix( lColour5, lColour6, lfHeight7 );
#else
    int liIndex = int( floor( lTile1Vec4[ 0 ] ) );
    vec3 lOriginalColourVec3 = ARRAY_LOOKUP_FS( lCustomUniforms, gaAverageColoursVec4, liIndex ).rgb;
    vec3 lRecolourVec3       = ARRAY_LOOKUP_FS( lCustomUniforms, gaTerrainColoursVec4, liIndex ).rgb;
    return GetTriPlanarColourArray(
        lTileCoordsVec2,
        SAMPLER2DARRAYPARAM( lDiffuseMap ),
        SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ),
        int( lTile1Vec4[ 0 ] ),
        lOriginalColourVec3,
        lRecolourVec3 );
#endif
}

vec3
GetTileColourAndNormal(
    in  CustomPerMaterialUniforms lCustomUniforms,
    in  vec3           lSmoothNormalVec3,
    in  vec3           lFacetNormalVec3,
    in  vec3           lCenterPositionVec3,
    in  vec3           lTilePositionVec3,  
    in  uvec4           lTileTextureIndicesSmall1Vec4,
    in  uvec4           lTileTextureIndicesSmall2Vec4,
    in  uvec4           lTileTextureIndicesLarge1Vec4,
    in  uvec4           lTileTextureIndicesLarge2Vec4,
    in  float          lfTileType,
    in  float          lfSlope,
    in  float          lfPatch,
    out vec3           lOutWorldNormalVec3,
    in  float          lfSmallScale,
    in  float          lfLargeScale,
    in  float          lfFade, 
    SAMPLER2DARRAYARG( lDiffuseMap ),
    SAMPLER2DARRAYARG( lNormalMap  ),
    SAMPLER2DARRAYARG( lSubstanceDiffuseMap ),
    SAMPLER2DARRAYARG( lSubstanceNormalMap  ),
    out float          lfSpecular,
    out float          lfSubsurface,
    out float          lfMetallic,
    out float          lfGlow )
{

    #if defined( D_TERRAIN_X_FACING )
    vec3    lWeightsVec3 = vec3( 1.0, 0.0, 0.0 );
    #elif defined( D_TERRAIN_Y_FACING )
    vec3    lWeightsVec3 = vec3( 0.0, 1.0, 0.0 );
    #elif defined( D_TERRAIN_Z_FACING )
    vec3    lWeightsVec3 = vec3( 0.0, 0.0, 1.0 );
    #else
    vec3    lWeightsVec3 = pow( abs( lSmoothNormalVec3 ), vec3( 32.0,32.0,32.0 ) );
    #endif

    vec3    lTexCoordsVec3;
    vec3    lSmallTexCoordsVec3;
    vec3    lLargeTexCoordsVec3;
    float   lfWeightRecip = 1.0 / ( lWeightsVec3.x + lWeightsVec3.y + lWeightsVec3.z );
    vec3    lNormalVec3;

#if 0
    {
        float lfDot = dot(normalize(lSmoothNormalVec3), normalize(lFacetNormalVec3));

        lNormalVec3 = mix( lFacetNormalVec3, lSmoothNormalVec3, smoothstep(0.9, 0.95, lfDot ) );
    }
#else
    lNormalVec3 = lSmoothNormalVec3;
#endif

    lfSubsurface = 0.0;
    lfMetallic   = 0.0;
    lfGlow       = 0.0;

    // these two offsets tell us how much fractional part of the planet offset is left
    // after the texture has wrapped around many many times. They have some error but
    // it is the same error everywhere on a planet - so it should not have a visible effect.
    vec3 lCenterPositionFlippedVec3 = lCenterPositionVec3;
    lCenterPositionFlippedVec3.y    = -lCenterPositionFlippedVec3.y; // this must match the y flip of the tex coords
    vec3 lTextureOffsetSmall        = fract( lCenterPositionFlippedVec3 * lfSmallScale );
    vec3 lTextureOffsetLarge        = fract( lCenterPositionFlippedVec3 * lfLargeScale );

    lTexCoordsVec3      = lTilePositionVec3; 
    lTexCoordsVec3.y    = -lTexCoordsVec3.y;
    lSmallTexCoordsVec3 = ( lTexCoordsVec3 * lfSmallScale ) + lTextureOffsetSmall;
    lLargeTexCoordsVec3 = ( lTexCoordsVec3 * lfLargeScale ) + lTextureOffsetLarge; 

    vec3 lWeightsVec3N = lWeightsVec3 * lfWeightRecip;


    // Normals + (Spec and Height)
    float lafHeights[7] = { 0., 0, 0, 0, 0, 0, 0 };
    {
        vec3  lSmallMappedNormalVec3 = vec3( 0.0, 0.0, 0.0 );
        vec3  lLargeMappedNormalVec3 = vec3( 0.0, 0.0, 0.0 );
        vec3  lSpecularLargeVec3     = vec3(0.0, 0.0, 0.0);
        vec3  lSpecularSmallVec3     = vec3(0.0, 0.0, 0.0);
        vec3  lHeightsLargeVec3[ 7 ] = { vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ) };
        vec3  lHeightsSmallVec3[ 7 ] = { vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5 ) };
        float lfFadeThreshold        = 1.0 / 100.0;

        if( lfFade > lfFadeThreshold )
        {
            if( lWeightsVec3N.x > 0.003 )
            {
                vec3 lNormalLargeVec3  = GetBlendedNormal( lLargeTexCoordsVec3.zy, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), lTileTextureIndicesLarge1Vec4, lTileTextureIndicesLarge2Vec4, lfTileType, lfSlope, lfPatch, lSpecularLargeVec3.x,
                                                           lHeightsLargeVec3[ 0 ].x, lHeightsLargeVec3[ 1 ].x, lHeightsLargeVec3[ 2 ].x, lHeightsLargeVec3[ 3 ].x, lHeightsLargeVec3[ 4 ].x, lHeightsLargeVec3[ 5 ].x, lHeightsLargeVec3[ 6 ].x );

                lLargeMappedNormalVec3 += lfFade * lWeightsVec3N.x * vec3( 0.0, lNormalLargeVec3.x, lNormalLargeVec3.y );  // YZ 
            }

            if( lWeightsVec3N.y > 0.003 )
            {
                vec3 lNormalLargeVec3 = GetBlendedNormal( lLargeTexCoordsVec3.zx, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), lTileTextureIndicesLarge1Vec4, lTileTextureIndicesLarge2Vec4, lfTileType, lfSlope, lfPatch, lSpecularLargeVec3.y,
                                                          lHeightsLargeVec3[ 0 ].y, lHeightsLargeVec3[ 1 ].y, lHeightsLargeVec3[ 2 ].y, lHeightsLargeVec3[ 3 ].y, lHeightsLargeVec3[ 4 ].y, lHeightsLargeVec3[ 5 ].y, lHeightsLargeVec3[ 6 ].y );

                lLargeMappedNormalVec3 += lfFade * lWeightsVec3N.y * vec3( -lNormalLargeVec3.x, 0.0, lNormalLargeVec3.y );  // ZX
            }

            if( lWeightsVec3N.z > 0.003 )
            {
                vec3 lNormalLargeVec3 = GetBlendedNormal( lLargeTexCoordsVec3.xy, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), lTileTextureIndicesLarge1Vec4, lTileTextureIndicesLarge2Vec4, lfTileType, lfSlope, lfPatch, lSpecularLargeVec3.z,
                                                          lHeightsLargeVec3[ 0 ].z, lHeightsLargeVec3[ 1 ].z, lHeightsLargeVec3[ 2 ].z, lHeightsLargeVec3[ 3 ].z, lHeightsLargeVec3[ 4 ].z, lHeightsLargeVec3[ 5 ].z, lHeightsLargeVec3[ 6 ].z );

                lLargeMappedNormalVec3 += lfFade * lWeightsVec3N.z * vec3( lNormalLargeVec3.y, lNormalLargeVec3.x, 0.0 );  // XY
            }
        }
        else
        {
            lfFade = 0.0;
        }

        if( lfFade < 1.0 - lfFadeThreshold )
        {
            if( lWeightsVec3N.x > 0.003 )
            {
                vec3 lNormalSmallVec3  = GetBlendedNormal( lSmallTexCoordsVec3.zy, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), lTileTextureIndicesSmall1Vec4, lTileTextureIndicesSmall2Vec4, lfTileType, lfSlope, lfPatch, lSpecularSmallVec3.x,
                                                           lHeightsSmallVec3[ 0 ].x, lHeightsSmallVec3[ 1 ].x, lHeightsSmallVec3[ 2 ].x, lHeightsSmallVec3[ 3 ].x, lHeightsSmallVec3[ 4 ].x, lHeightsSmallVec3[ 5 ].x, lHeightsSmallVec3[ 6 ].x );

                lSmallMappedNormalVec3 += (1.0 - lfFade ) * lWeightsVec3N.x * vec3( 0.0, lNormalSmallVec3.x, lNormalSmallVec3.y );  // YZ 
            }

            if( lWeightsVec3N.y > 0.003 )
            {
                vec3 lNormalSmallVec3 = GetBlendedNormal( lSmallTexCoordsVec3.zx, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), lTileTextureIndicesSmall1Vec4, lTileTextureIndicesSmall2Vec4, lfTileType, lfSlope, lfPatch, lSpecularSmallVec3.y,
                                                          lHeightsSmallVec3[ 0 ].y, lHeightsSmallVec3[ 1 ].y, lHeightsSmallVec3[ 2 ].y, lHeightsSmallVec3[ 3 ].y, lHeightsSmallVec3[ 4 ].y, lHeightsSmallVec3[ 5 ].y, lHeightsSmallVec3[ 6 ].y );

                lSmallMappedNormalVec3 += (1.0 - lfFade ) * lWeightsVec3N.y * vec3( -lNormalSmallVec3.x, 0.0, lNormalSmallVec3.y );  // ZX
            }

            if( lWeightsVec3N.z > 0.003 )
            {
                vec3 lNormalSmallVec3 = GetBlendedNormal( lSmallTexCoordsVec3.xy, SAMPLER2DARRAYPARAM( lNormalMap ), SAMPLER2DARRAYPARAM( lSubstanceNormalMap ), lTileTextureIndicesSmall1Vec4, lTileTextureIndicesSmall2Vec4, lfTileType, lfSlope, lfPatch, lSpecularSmallVec3.z,
                                                          lHeightsSmallVec3[ 0 ].z, lHeightsSmallVec3[ 1 ].z, lHeightsSmallVec3[ 2 ].z, lHeightsSmallVec3[ 3 ].z, lHeightsSmallVec3[ 4 ].z, lHeightsSmallVec3[ 5 ].z, lHeightsSmallVec3[ 6 ].z );

                lSmallMappedNormalVec3 += (1.0 - lfFade ) * lWeightsVec3N.z * vec3( lNormalSmallVec3.y, lNormalSmallVec3.x, 0.0 );  // XY
            }
        }
        else
        {
            lfFade = 1.0;
        }


        {
            for( int i = 0; i < 7; i++ )
            {
                float lfHeightLarge = dot( lHeightsLargeVec3[ i ], lWeightsVec3 ) * lfWeightRecip;
                float lfHeightSmall = dot( lHeightsSmallVec3[ i ], lWeightsVec3 ) * lfWeightRecip;
                lafHeights[ i ]     = mix( lfHeightSmall, lfHeightLarge, lfFade );
            }

            lafHeights[ 0 ]     = smoothstep( lafHeights[ 0 ] - 0.12, lafHeights[ 0 ] + 0.12, lfTileType );
            lafHeights[ 1 ]     = smoothstep( lafHeights[ 1 ] - 0.12, lafHeights[ 1 ] + 0.12, lfTileType );
            lafHeights[ 2 ]     = smoothstep( lafHeights[ 2 ] - 0.12, lafHeights[ 2 ] + 0.12, lfTileType );
            lafHeights[ 3 ]     = smoothstep( lafHeights[ 3 ] - 0.12, lafHeights[ 3 ] + 0.12, lfTileType );
            lafHeights[ 4 ]     = smoothstep( lafHeights[ 4 ] - 0.12, lafHeights[ 4 ] + 0.12, lfSlope );
            lafHeights[ 5 ]     = smoothstep( lafHeights[ 5 ] - 0.12, lafHeights[ 5 ] + 0.12, lfSlope );
            lafHeights[ 6 ]     = smoothstep( lafHeights[ 6 ] - 0.12, lafHeights[ 6 ] + 0.12, lfPatch );

            float lfSpecularLarge = dot(lSpecularLargeVec3, lWeightsVec3) * lfWeightRecip;
            float lfSpecularSmall = dot(lSpecularSmallVec3, lWeightsVec3) * lfWeightRecip;

            lSmallMappedNormalVec3 = vec3( lSmallMappedNormalVec3.x + lLargeMappedNormalVec3.x, lSmallMappedNormalVec3.y * lLargeMappedNormalVec3.y, lSmallMappedNormalVec3.z + lLargeMappedNormalVec3.z );
            lOutWorldNormalVec3 = normalize( lNormalVec3 + lSmallMappedNormalVec3 * 1.2 );

            lfSpecular        = mix( lfSpecularSmall, lfSpecularLarge, lfFade );
        }
    }

#ifdef D_PLATFORM_PC

    vec3 lTileColourVec3 = vec3(0.0, 0.0, 0.0);

    {
        if (lWeightsVec3N.x * lfFade  > 0.003)
        {
            lTileColourVec3 += lfFade * lWeightsVec3N.x * GetBlendedColour(lCustomUniforms, lLargeTexCoordsVec3.zy, SAMPLER2DARRAYPARAM(lDiffuseMap), SAMPLER2DARRAYPARAM(lSubstanceDiffuseMap), lTileTextureIndicesLarge1Vec4, lTileTextureIndicesLarge2Vec4,
                lafHeights[0], lafHeights[1], lafHeights[2], lafHeights[3], lafHeights[4], lafHeights[5], lafHeights[6], lfMetallic).xyz;
        }
        if (lWeightsVec3N.y * lfFade > 0.003)
        {
            lTileColourVec3 += lfFade * lWeightsVec3N.y * GetBlendedColour(lCustomUniforms, lLargeTexCoordsVec3.zx, SAMPLER2DARRAYPARAM(lDiffuseMap), SAMPLER2DARRAYPARAM(lSubstanceDiffuseMap), lTileTextureIndicesLarge1Vec4, lTileTextureIndicesLarge2Vec4,
                lafHeights[0], lafHeights[1], lafHeights[2], lafHeights[3], lafHeights[4], lafHeights[5], lafHeights[6], lfMetallic).xyz;
        }
        if (lWeightsVec3N.z * lfFade > 0.003)
        {
            lTileColourVec3 += lfFade * lWeightsVec3N.z * GetBlendedColour(lCustomUniforms, lLargeTexCoordsVec3.xy, SAMPLER2DARRAYPARAM(lDiffuseMap), SAMPLER2DARRAYPARAM(lSubstanceDiffuseMap), lTileTextureIndicesLarge1Vec4, lTileTextureIndicesLarge2Vec4,
                lafHeights[0], lafHeights[1], lafHeights[2], lafHeights[3], lafHeights[4], lafHeights[5], lafHeights[6], lfMetallic).xyz;
        }

        if (lWeightsVec3N.x * (1.0 - lfFade) > 0.003)
        {
            lTileColourVec3 += (1.0 - lfFade) * lWeightsVec3N.x * GetBlendedColour(lCustomUniforms, lSmallTexCoordsVec3.zy, SAMPLER2DARRAYPARAM(lDiffuseMap), SAMPLER2DARRAYPARAM(lSubstanceDiffuseMap), lTileTextureIndicesSmall1Vec4, lTileTextureIndicesSmall2Vec4,
                lafHeights[0], lafHeights[1], lafHeights[2], lafHeights[3], lafHeights[4], lafHeights[5], lafHeights[6], lfMetallic).xyz;
        }
        if (lWeightsVec3N.y * (1.0 - lfFade) > 0.003)
        {
            lTileColourVec3 += (1.0 - lfFade) * lWeightsVec3N.y * GetBlendedColour(lCustomUniforms, lSmallTexCoordsVec3.zx, SAMPLER2DARRAYPARAM(lDiffuseMap), SAMPLER2DARRAYPARAM(lSubstanceDiffuseMap), lTileTextureIndicesSmall1Vec4, lTileTextureIndicesSmall2Vec4,
                lafHeights[0], lafHeights[1], lafHeights[2], lafHeights[3], lafHeights[4], lafHeights[5], lafHeights[6], lfMetallic).xyz;
        }
        if (lWeightsVec3N.z * (1.0 - lfFade) > 0.003)
        {
            lTileColourVec3 += (1.0 - lfFade) * lWeightsVec3N.z * GetBlendedColour(lCustomUniforms, lSmallTexCoordsVec3.xy, SAMPLER2DARRAYPARAM(lDiffuseMap), SAMPLER2DARRAYPARAM(lSubstanceDiffuseMap), lTileTextureIndicesSmall1Vec4, lTileTextureIndicesSmall2Vec4,
                lafHeights[0], lafHeights[1], lafHeights[2], lafHeights[3], lafHeights[4], lafHeights[5], lafHeights[6], lfMetallic).xyz;
        }
    }

#else

    vec3    lTileColourSmallVec3 = vec3( 0.0, 0.0, 0.0 );
    vec3    lTileColourLargeVec3 = vec3( 0.0, 0.0, 0.0 );
    {
        if( lWeightsVec3N.x > 0.003 )
        {
            lTileColourLargeVec3 += lWeightsVec3N.x * GetBlendedColour( lCustomUniforms, lLargeTexCoordsVec3.zy, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), lTileTextureIndicesLarge1Vec4, lTileTextureIndicesLarge2Vec4,
                                                                                    lafHeights[ 0 ], lafHeights[ 1 ], lafHeights[ 2 ], lafHeights[ 3 ], lafHeights[ 4 ], lafHeights[ 5 ], lafHeights[ 6 ], lfMetallic ).xyz;
            lTileColourSmallVec3 += lWeightsVec3N.x * GetBlendedColour( lCustomUniforms, lSmallTexCoordsVec3.zy, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), lTileTextureIndicesSmall1Vec4, lTileTextureIndicesSmall2Vec4,
                                                                                      lafHeights[ 0 ], lafHeights[ 1 ], lafHeights[ 2 ], lafHeights[ 3 ], lafHeights[ 4 ], lafHeights[ 5 ], lafHeights[ 6 ], lfMetallic ).xyz;
        }
        if( lWeightsVec3N.y > 0.003 )
        {
            lTileColourLargeVec3 += lWeightsVec3N.y * GetBlendedColour( lCustomUniforms, lLargeTexCoordsVec3.zx, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), lTileTextureIndicesLarge1Vec4, lTileTextureIndicesLarge2Vec4,
                                                                                    lafHeights[ 0 ], lafHeights[ 1 ], lafHeights[ 2 ], lafHeights[ 3 ], lafHeights[ 4 ], lafHeights[ 5 ], lafHeights[ 6 ], lfMetallic ).xyz;
            lTileColourSmallVec3 += lWeightsVec3N.y * GetBlendedColour( lCustomUniforms, lSmallTexCoordsVec3.zx, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), lTileTextureIndicesSmall1Vec4, lTileTextureIndicesSmall2Vec4,
                                                                                      lafHeights[ 0 ], lafHeights[ 1 ], lafHeights[ 2 ], lafHeights[ 3 ], lafHeights[ 4 ], lafHeights[ 5 ], lafHeights[ 6 ], lfMetallic ).xyz;
        }
        if( lWeightsVec3N.z > 0.003 )
        {
            lTileColourLargeVec3 += lWeightsVec3N.z * GetBlendedColour( lCustomUniforms, lLargeTexCoordsVec3.xy, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), lTileTextureIndicesLarge1Vec4, lTileTextureIndicesLarge2Vec4,
                                                                                    lafHeights[ 0 ], lafHeights[ 1 ], lafHeights[ 2 ], lafHeights[ 3 ], lafHeights[ 4 ], lafHeights[ 5 ], lafHeights[ 6 ], lfMetallic ).xyz;
            lTileColourSmallVec3 += lWeightsVec3N.z * GetBlendedColour( lCustomUniforms, lSmallTexCoordsVec3.xy, SAMPLER2DARRAYPARAM( lDiffuseMap ), SAMPLER2DARRAYPARAM( lSubstanceDiffuseMap ), lTileTextureIndicesSmall1Vec4, lTileTextureIndicesSmall2Vec4,
                                                                                      lafHeights[ 0 ], lafHeights[ 1 ], lafHeights[ 2 ], lafHeights[ 3 ], lafHeights[ 4 ], lafHeights[ 5 ], lafHeights[ 6 ], lfMetallic ).xyz;
        }
    }

    vec3 lTileColourVec3;

    lTileColourVec3 = mix( lTileColourSmallVec3, lTileColourLargeVec3, lfFade );
#endif

    lTileColourVec3 = GammaCorrectInput( lTileColourVec3 );
  
    return lTileColourVec3;
}


#endif	

#endif
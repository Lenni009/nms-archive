////////////////////////////////////////////////////////////////////////////////
///
///     @file       DoFFragment.h
///     @author     User
///     @date       
///
///     @brief      DepthOfFieldFragmentShader
///
///     Copyright (c) 2008 Hello Games Ltd. All Rights Reserved.
///
////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//      Compilation defines 


//-----------------------------------------------------------------------------
//      Include files

#include "Common/Defines.shader.h"
#include "Common/CommonUniforms.shader.h"
#include "Common/Common.shader.h"
#include "Common/CommonDepth.shader.h"
#include "Common/CommonPostProcess.shader.h"

#include "Fullscreen/PostCommon.h"

// =================================================================================================

#if defined( D_GUASS_BLUR_RADIUS_4 )
#define D_GUASS_BLUR_RADIUS 4
#elif defined( D_GUASS_BLUR_RADIUS_3 )
#define D_GUASS_BLUR_RADIUS 3
#elif defined( D_GUASS_BLUR_RADIUS_2 )
#define D_GUASS_BLUR_RADIUS 2
#endif


// =================================================================================================
//
// TONEMAP_COPY
//
// =================================================================================================

#ifdef D_DEPTHOFFIELD_TONEMAP_DEPTH

//-----------------------------------------------------------------------------
//      Global Data


//-----------------------------------------------------------------------------
//      Typedefs and Classes 

DECLARE_INPUT
    IN_SCREEN_POSITION

    INPUT( vec2, mTexCoordsVec2, TEXCOORD0 )
DECLARE_END


//-----------------------------------------------------------------------------
//      Functions 


FRAGMENT_MAIN_COLOUR_SRT
{
    #ifdef D_DOWNSAMPLE_4

    vec2 lPixelStep = lUniforms.mpPerFrame->gFrameBufferSizeVec4.zw * 0.25;   

    vec2 lTexCoords = IN(mTexCoordsVec2);

    vec2 lTexCoords0 = lTexCoords + vec2( -lPixelStep.x, -lPixelStep.y );
    vec2 lTexCoords1 = lTexCoords + vec2(  lPixelStep.x, -lPixelStep.y );
    vec2 lTexCoords2 = lTexCoords + vec2( -lPixelStep.x,  lPixelStep.y );
    vec2 lTexCoords3 = lTexCoords + vec2(  lPixelStep.x,  lPixelStep.y );

    vec2 lTexCoords4 = lTexCoords + vec2( -lPixelStep.x * 3.0, 0.0 );
    vec2 lTexCoords5 = lTexCoords + vec2(  lPixelStep.x * 3.0, 0.0 );
    vec2 lTexCoords6 = lTexCoords + vec2(  0.0,          -lPixelStep.y * 3.0 );
    vec2 lTexCoords7 = lTexCoords + vec2(  0.0,           lPixelStep.y * 3.0 );

    /*
    vec4 lFragmentColourVec4 = vec4(0,0,0,1);

    vec4 lFragmentColour0Vec4 = texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords0 );
    vec4 lFragmentColour1Vec4 = texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords1 );
    vec4 lFragmentColour2Vec4 = texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords2 );
    vec4 lFragmentColour3Vec4 = texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords3 );

    lFragmentColour0Vec4.xyz     = TonemapKodak(lFragmentColour0Vec4.rgb) / TonemapKodak( vec3(1.0,1.0,1.0) );
    lFragmentColour1Vec4.xyz     = TonemapKodak(lFragmentColour1Vec4.rgb) / TonemapKodak( vec3(1.0,1.0,1.0) );
    lFragmentColour2Vec4.xyz     = TonemapKodak(lFragmentColour2Vec4.rgb) / TonemapKodak( vec3(1.0,1.0,1.0) );
    lFragmentColour3Vec4.xyz     = TonemapKodak(lFragmentColour3Vec4.rgb) / TonemapKodak( vec3(1.0,1.0,1.0) );

    lFragmentColourVec4.xyz = 0.25 * ( lFragmentColour0Vec4.xyz + lFragmentColour1Vec4.xyz + lFragmentColour2Vec4.xyz + lFragmentColour3Vec4.xyz );
*/

    vec4 lFragmentColourVec4 = vec4(0,0,0,1); 

    lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords0 ).xyz );
    lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords1 ).xyz );
    lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords2 ).xyz );
    lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords3 ).xyz );

    lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords4 ).xyz );
    lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords5 ).xyz );
    lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords6 ).xyz );
    lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords7 ).xyz );

    lFragmentColourVec4.xyz /= TonemapKodak( vec3(1.0,1.0,1.0) );
    lFragmentColourVec4.xyz /= 8.0;

    #elif defined( D_DOWNSAMPLE_16 )

    vec2 lPixelStep = lUniforms.mpPerFrame->gFrameBufferSizeVec4.zw * 0.25;   

    vec2 lTexCoords = IN(mTexCoordsVec2);
    vec2 lTexCoordsStart = lTexCoords + vec2( -lPixelStep.x, -lPixelStep.y ) * 1.5;

    vec4 lFragmentColourVec4 = vec4(0,0,0,1);

    for( float y = 0.0; y < 4.0; y += 1.0 )
    {
        for( float x = 0.0; x < 4.0; x += 1.0 )
        {
            
            vec2 lTexCoords0 = lTexCoordsStart + lPixelStep * vec2( x, y );   
            lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords0 ).xyz );
        }
    }

    for( float i = -1.0; i <= 1.0; i += 1.0 )
    {
        vec2 lTexCoords0 = lTexCoords + lPixelStep * vec2(  2.5, i );   
        vec2 lTexCoords1 = lTexCoords + lPixelStep * vec2( -2.5, i );   
        vec2 lTexCoords2 = lTexCoords + lPixelStep * vec2( i,  2.5 );   
        vec2 lTexCoords3 = lTexCoords + lPixelStep * vec2( i, -2.5 );   

        lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords0 ).xyz );
        lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords1 ).xyz );
        lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords2 ).xyz );
        lFragmentColourVec4.xyz += TonemapKodak( texture2D( lUniforms.mpCustomPerMesh->gBufferMap, lTexCoords3 ).xyz );
    }


    lFragmentColourVec4.xyz /= TonemapKodak( vec3(1.0,1.0,1.0) );
    lFragmentColourVec4.xyz *= ( 1.0 / 28.0 );

    #else

    vec4 lFragmentColourVec4    = texture2D( lUniforms.mpCustomPerMesh->gBufferMap, IN(mTexCoordsVec2) );

    //if (lUniforms.mpCustomPerMesh->gHDRParamsVec4.z == 0.0)        // Only tonemap if we aren't in true HDR mode
    {
        lFragmentColourVec4.xyz     = TonemapKodak(lFragmentColourVec4.rgb) / TonemapKodak( vec3(1.0,1.0,1.0) );
    }
    #endif

    //lFragmentColourVec4.xyz     = GammaCorrectOutput( lFragmentColourVec4.xyz );
    
    FRAGMENT_COLOUR             = vec4( lFragmentColourVec4.xyz, 1.0 );
    //FRAGMENT_COLOUR             = vec4( 1.0, 0.0, 0.0,  1.0 );
}

#endif



// =================================================================================================
//
// BLEND
//
// =================================================================================================

#ifdef D_DEPTHOFFIELD_BLEND

//-----------------------------------------------------------------------------
//      Global Data


//-----------------------------------------------------------------------------
//      Typedefs and Classes 

DECLARE_INPUT
IN_SCREEN_POSITION

INPUT(vec2, mTexCoordsVec2, TEXCOORD0)
DECLARE_END


//-----------------------------------------------------------------------------
//      Functions 

FRAGMENT_MAIN_COLOUR_SRT
{
    vec4 lFragmentColourVec4;
    lFragmentColourVec4.a   = texture2D(lUniforms.mpCustomPerMesh->gBuffer1Map, IN(mTexCoordsVec2)).r;
    if (lFragmentColourVec4.a == 0.0)
    {
        discard;
    }
    lFragmentColourVec4.rgb = texture2D(lUniforms.mpCustomPerMesh->gBufferMap, IN(mTexCoordsVec2)).rgb;
    FRAGMENT_COLOUR = lFragmentColourVec4;
}

#endif


// =================================================================================================
//
// GUASS_DEPTH
//
// =================================================================================================

#ifdef D_DEPTHOFFIELD_GUASS_DEPTH

#ifdef D_PLATFORM_ORBIS
//#pragma argument(unrollallloops)
#endif


//-----------------------------------------------------------------------------
//      Global Data


//blur params x = bool x-axis, y = bool y-axis, z = Sigma
// The sigma value for the gaussian function: higher value means more blur
// A good value for 9x9 is around 3 to 5
// A good value for 7x7 is around 2.5 to 4
// A good value for 5x5 is around 2 to 3.5
// ... play around with this based on what you need :)


//-----------------------------------------------------------------------------
//      Typedefs and Classes 

DECLARE_INPUT
    IN_SCREEN_POSITION

    INPUT( vec2, mTexCoordsVec2, TEXCOORD0 )
DECLARE_END


//-----------------------------------------------------------------------------
//      Functions 
STATIC_CONST float pi = 3.14159265;


FRAGMENT_MAIN_COLOUR_SRT
{    
    vec3   incrementalGaussian; // Incremental Gaussian Coefficent Calculation (See GPU Gems 3 pp. 877 - 889)
    vec4   avgValue = vec4(0.0, 0.0, 0.0, 0.0);
    vec4   lCenter;
    float coefficientSum = 0.0;
    float sigma;


    lCenter.rgb = texture2D( lUniforms.mpCustomPerMesh->gBufferMap, IN(mTexCoordsVec2) ).rgb;
    lCenter.w   = texture2D( lUniforms.mpCustomPerMesh->gBuffer1Map, IN(mTexCoordsVec2)).r;

    if ( lCenter.w == 0.0 )
    {
#if defined ( D_GUASS_BLUR_DISCARD )
		discard;
#else		    	
        FRAGMENT_COLOUR = lCenter;
        return;
#endif              
    }
    
    vec4 lBlurParamsVec4 = lUniforms.mpCustomPerMesh->gBlurParamsVec4;

    // The sigma value for the gaussian function: higher value means more blur
    // A good value for 9x9 is around 3 to 5
    // A good value for 7x7 is around 2.5 to 4
    // A good value for 5x5 is around 2 to 3.5
    // ... play around with this based on what you need :)
    sigma = lBlurParamsVec4.z * lCenter.w * lUniforms.mpCustomPerMesh->gHDRParamsVec4.w;

    incrementalGaussian.x = 1.0 / (sqrt(2.0 * 3.14159265) * sigma);
    incrementalGaussian.y = exp(-0.5 / (sigma * sigma));
    incrementalGaussian.z = incrementalGaussian.y * incrementalGaussian.y;

    // Take the central sample first...
    avgValue.xyz            = lCenter.xyz * incrementalGaussian.x;
    coefficientSum         += incrementalGaussian.x;
    incrementalGaussian.xy *= incrementalGaussian.yz;
    
    // Go through the remaining 8 vertical samples (4 on each side of the center)
    for (float i = 1.0; i <= 8 ; i++) 
    {
        vec4 lTexPos;
        vec4 lTexNeg;

        lTexPos = texture2D( lUniforms.mpCustomPerMesh->gBufferMap, IN(mTexCoordsVec2).xy + i * (lBlurParamsVec4.xy * lUniforms.mpPerFrame->gFrameBufferSizeVec4.zw) );
        lTexNeg = texture2D( lUniforms.mpCustomPerMesh->gBufferMap, IN(mTexCoordsVec2).xy - i * (lBlurParamsVec4.xy * lUniforms.mpPerFrame->gFrameBufferSizeVec4.zw) );
        
        
        avgValue.xyz += mix( lCenter.xyz, lTexNeg.xyz, lTexNeg.w ) * incrementalGaussian.x;         
        avgValue.xyz += mix( lCenter.xyz, lTexPos.xyz, lTexPos.w ) * incrementalGaussian.x; 
        
        
      //  avgValue.xyz += lTexNeg.xyz * incrementalGaussian.x;         
      //  avgValue.xyz += lTexPos.xyz * incrementalGaussian.x;
               
        coefficientSum         += 2.0 * incrementalGaussian.x;
        incrementalGaussian.xy *= incrementalGaussian.yz;
    }

    FRAGMENT_COLOUR = vec4( avgValue.xyz / coefficientSum, lCenter.w );
}

#endif
